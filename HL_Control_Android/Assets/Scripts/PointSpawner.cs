using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class PointSpawner : MonoBehaviour
{
    public RectTransform parentImage; // The container for the markers
    public GameObject markerPrefab; // The prefab for individual markers
    public float movemetMultiplier = 20f;

    private GameObject[,] markers; // Array to store the marker GameObjects
    private const int markerCount = 360; // Total number of markers to spawn

    private void Start()
    {
        // Initialize the array of markers
        markers = new GameObject[markerCount, 2];

        // Instantiate markers and add them as children of the parentImage
        for (int i = 0; i < markerCount; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                GameObject marker = Instantiate(markerPrefab, parentImage.GetChild(j+1));
                marker.SetActive(false); // Markers are initially invisible
                markers[i,j] = marker;
            }
            markers[i, 0].GetComponent<Image>().color = new Color32(255, 0, 0, 255);
            markers[i, 1].GetComponent<Image>().color = new Color32(0, 255, 0, 255);
        }
    }

// TEST
/*
    public float point1X = 0.0f; // Public X coordinate for the first point
    public float point1Z = 0.0f; // Public Z coordinate for the first point
    public float point2X = 0.0f; // Public X coordinate for the second point
    public float point2Z = 0.0f; // Public Z coordinate for the second point
     private void Update()
    {
        // Convert public points to a byte array
        byte[] byteArray = CreateByteArrayFromPoints(point1X, point1Z, point2X, point2Z);

        // Update markers using the generated byte array
        UpdateMarkers(byteArray);
    }

    // Creates a byte array from two points (x1, z1) and (x2, z2)
    private byte[] CreateByteArrayFromPoints(float x1, float z1, float x2, float z2)
    {
        byte[] byteArray = new byte[16]; // 4 floats * 4 bytes each = 16 bytes

        System.Buffer.BlockCopy(System.BitConverter.GetBytes(x1), 0, byteArray, 0, 4);
        System.Buffer.BlockCopy(System.BitConverter.GetBytes(z1), 0, byteArray, 4, 4);
        System.Buffer.BlockCopy(System.BitConverter.GetBytes(x2), 0, byteArray, 8, 4);
        System.Buffer.BlockCopy(System.BitConverter.GetBytes(z2), 0, byteArray, 12, 4);

        return byteArray;
    } */

    // Updates the markers based on an array of bytes
    public void UpdateMarkers(byte[] beats, string height)
    {
        // Each float requires 4 bytes, so the total number of floats is beats.Length / 4
        if (beats.Length % 4 != 0)
        {
            Debug.LogError("The byte array length must be a multiple of 4 (each float is 4 bytes).\n");
            return;
        }

        // Convert the byte array into a float array
        int floatCount = beats.Length / 4;
        float[] floatArray = new float[floatCount];
        for (int i = 0; i < floatCount; i++)
        {
            floatArray[i] = System.BitConverter.ToSingle(beats, i * 4);
        }

        // Ensure the float array can form pairs of x and z
        if (floatArray.Length % 2 != 0)
        {
            Debug.LogError("The float array must contain pairs of x and z values.\n");
            return;
        }

        // Determine the number of markers to update, limited by markerCount
        int pairCount = Mathf.Min(floatArray.Length / 2, markerCount);
        Debug.Log("pairCount: " + pairCount);

        for (int i = 0; i < pairCount; i++)
        {
            // Extract x and z values from the float array
            float x = floatArray[i * 2]; // First value of the pair
            float z = floatArray[i * 2 + 1]; // Second value of the pair

            // Create a position vector using the x and z values
            Vector2 position = new Vector2(x, z);
            //Debug.Log(i + "# Marker position: " + position);

            // Update the marker's position and make it visible
            
            if (height == "low")
            {
                SetMarkerPosition(markers[i,0], position / movemetMultiplier);
                markers[i,0].SetActive(true);
                // Deactivate unused markers
                for (int k = pairCount; k < markerCount; k++)
                {
                    markers[k,0].SetActive(false);
                }
            }
            else
            {
                SetMarkerPosition(markers[i, 1], position / movemetMultiplier);
                markers[i,1].SetActive(true);
                // Deactivate unused markers
                for (int k = pairCount; k < markerCount; k++)
                {
                    markers[k,1].SetActive(false);
                }
            }
        }        
    }

    // Sets the position of a marker based on a Vector2
    private void SetMarkerPosition(GameObject marker, Vector2 position)
    {
        // Calculate the anchored position relative to the parentImage's size
        Vector2 anchoredPosition = new Vector2(
            position.x * parentImage.rect.width,// - parentImage.rect.width / 2,
            position.y * parentImage.rect.height// - parentImage.rect.height / 2
        );

        // Apply the anchored position to the marker's RectTransform
        RectTransform markerRect = marker.GetComponent<RectTransform>();
        markerRect.anchoredPosition = anchoredPosition;
    }
}
